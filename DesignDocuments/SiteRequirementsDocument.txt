Site Requirements Document
1. Introduction
1.1 Purpose
This document outlines the comprehensive requirements for developing a web-based job and ticket management system. The system supports team collaboration for users in roles such as field technicians, managers, and administrators. It enables users to create, edit, and view jobs/tickets, manage miscellaneous tasks, handle notifications and alerts, and customize profiles. The application is semi-collaborative, where users input data individually but share visibility into updates like statistics, alerts, and notifications. Only the creator, managers, or admins can edit or delete entries, with specific restrictions: admins can edit their own content and delete manager or user content; managers can edit their own content and delete user content; all actions are logged in the history table for auditing. The system is designed for 15+ users, with features for multi-device login, real-time updates, and future integrations (e.g., Microsoft Teams). It prioritizes security, usability across desktop and mobile, and scalability for growth. The RESTful API is powered by PostgREST, leveraging the PostgreSQL schema for data access, with Django handling authentication, async tasks, and WebSocket-based features.
1.2 Scope
In Scope: User authentication (including future OAuth and email verification), job/ticket management, notifications/alerts, customizable UI, data import/export, asynchronous tasks, real-time features, admin-only access to development, maintenance, and event logs, admin-exclusive handling of admin-level alerts (security breaches, bugs, failed checks), admin ability to send notifications and site-wide alerts, and role-based content moderation with logging. RESTful API endpoints are auto-generated by PostgREST for all database tables/views, with Django managing non-API logic.Out of Scope: Full email verification implementation (stubbed with email_verification_tokens table), advanced password restrictions (stubbed), external integrations like Microsoft Teams (planned for later), payment processing.Assumptions: Users agree to terms prohibiting sharing sensitive data. Data is encrypted at-rest and in-transit. Initial deployment targets local/development environments, with Docker for production scalability.
1.3 References

Database schema from Database_schema.txt (primary reference, newest).
Dependencies from Requirements.txt and install.txt.
UI widgets from widgets.txt.
Pages and design from Pages.txt and DesignRequirements.txt.
Development guidelines from DevelopmentRequirements.txt.

2. Functional Requirements
2.1 User Management and Authentication

Registration: Users register with name, alias, email, and password (validated for match and minimum 8 characters). Must agree to terms and conditions (checkbox with link to terms page). Email verification stubbed (set user_is_email_verified to FALSE initially, supported by email_verification_tokens table for future implementation). Data stored via POST /users to PostgREST.
Login: Email/password-based, with future OAuth support (e.g., Google, Microsoft Authenticator) via oauth_provider and oauth_id fields. Django Allauth handles login, generating JWT tokens for PostgREST authentication. Supports concurrent login on up to 3 devices per user. Sessions expire after 24 hours of inactivity. Logout from one device doesn't affect others.
Session Management: Track sessions in user_sessions table (e.g., session_id as UUID, user_id, token, device_info, ip_address, issued_at, expires_at, last_accessed_at, is_active default FALSE). Sessions are active only when at least one login_origin is active; inactive when all origins are logged out. Enforce max 3 sessions by revoking oldest on new login (handled by Django, syncing with PostgREST JWT).
Role-Based Access:
Admins (user_is_admin = TRUE): Responsible for system development and maintenance, including managing infrastructure (e.g., Docker, PostgREST server, servers), handling updates, and monitoring system performance. Have exclusive access to admin-level alerts (security, system) and event logs (stored in history table via GET /history). Can send notifications to individual users, groups, or site-wide, and issue site-wide alerts (e.g., maintenance, terms updates) via POST /notifications and POST /alerts. Can edit their own content (e.g., tickets, tasks, notifications) and delete content created by managers or users, with all actions logged in the history table for auditing.
Managers (user_is_manager = TRUE): Manage users by moderating their content (e.g., tickets, tasks). Can act as a user (create/edit/view their own jobs/tasks). Can edit their own content and delete content created by non-manager users, with all actions logged in the history table. Cannot access admin-level alerts, event logs, or perform development/maintenance tasks.
Field Users: Access only their own data (e.g., tickets, tasks, profile). Can create/edit/view their own content via POST/PATCH /ticket_entries, with edits logged in the history table. Cannot delete or moderate others' content.
Groups: Users assigned to groups (field, manager, admin) via user_groups (many-to-many, composite key: user_id, group_id), accessible via GET /user_groups.


Preferences: Users edit preferences like color (user_preferred_color), landing page (user_preferred_landing_page), profile picture (user_preferred_profile_picture), light/dark mode (user_preferred_light_or_dark_mode_mobile default 'dark', user_preferred_light_or_dark_mode_desktop default 'light'), alerts/notifications (user_preferred_enable_alerts, user_preferred_enable_notifications as JSONB), timezone (user_preferred_timezone default 'America/Los_Angeles', validated against PostgreSQL pg_timezone_names). Updated via PATCH /users.

2.2 Job and Ticket Management

Tickets: Globally unique ticket numbers stored in tickets (one-to-many with entries in ticket_entries, linked by ticket_id). Each ticket is tied to one building via building_id. Supports soft deletion via deleted_at. Managed via GET/POST/PATCH/DELETE /tickets.
Job Entries: Create/edit/view jobs using fields from ticket_entries (e.g., entry_id as serial, user_id, ticket_id, job_name encrypted, dates/times, materials, device details, job_changed_flag default FALSE to track changes including device additions). Triggers alerts for non-null fields like job_materials_needed, job_access_needed, job_programming_changes, or if job_followup_required is TRUE, handled by database trigger. Managed via GET/POST/PATCH /ticket_entries.
Miscellaneous Tasks: Create/edit/view tasks in ticket_misc_entries (entry_id as serial, user_id, misc_name encrypted, misc_start_date, misc_start_time, deleted_at for soft deletion). Managed via GET/POST/PATCH /ticket_misc_entries.
Lookups: Buildings (building_id, building_uuid unique for external APIs/integrations, building_name, description encrypted) and devices (device_id, device_uuid unique for external APIs/integrations, building_id, device_name, device_type, description encrypted) from dedicated tables for dropdowns/references. Devices are globally unique and tied to one specific building (enforced by building_i...(truncated 6601 characters)...ndars (aggregates from GET /ticket_entries), Edit/View Job/Task widgets (field mappings with spacers), AdminEventLog (admin-only, displays GET /history data).


Pages: All centered with crisp, rounded content boxes. Themes: light/dark, desktop/mobile. Pages include:
Unauthenticated: Main (title/picture), Login (error messages), Registration (validation indicators), Terms/Conditions, Contact.
Authenticated: User Profile (overview + team summary), Preferences, Stats, Edit/View Job/Dailies/Summary, Calendar (user/team), Team Overview/Dailies/Stats/Calendar.
Restricted:
Administration: Admin-only page for system maintenance (e.g., view event logs via GET /history, manage infrastructure, resolve admin-level alerts via PATCH /alerts).
Management: Manager/admin page for moderating user content (e.g., delete user tickets/tasks via DELETE /ticket_entries) and managing team job-related alerts.




Interactivity: Editable fields as plain text until clicked. Live updates without page refresh, using WebSockets and PostgREST queries.

2.5 Data Import/Export

Imports: Support Microsoft Outlook emails, .msg, .eml, .json for populating jobs/tickets. Handled by Django, with data inserted via POST /ticket_entries or POST /tickets. Log operations in import_export_logs table via POST /import_export_logs.
Exports: JSON or clipboard for user data, fetched via GET /users or GET /ticket_entries. Log operations in import_export_logs table.

2.6 Other Features

Asynchronous Tasks: Background processing for notifications, alerts, imports via Celery/Redis.
File Uploads: Per-user multimedia storage (e.g., profile pictures), handled by Django and updated via PATCH /users.
Future Integrations: Stubs for OAuth (Google, Microsoft Authenticator) via oauth_provider, oauth_id, and email verification via email_verification_tokens. Stubs for Microsoft Teams webhooks.
Event Logs: Stored in the history table (history_id, table_name, record_id, action, user_id, changes, created_at). Accessible only to admins via the AdminEventLog widget or Administration page via GET /history. Logs all actions (create/edit/delete) by admins, managers, and users, including admin actions like sending notifications/alerts and deleting content, and manager actions like moderating/deleting user content.

3. Non-Functional Requirements
3.1 Security

Encryption: All user-submitted data encrypted at-rest (using PostgreSQL pgcrypto for sensitive fields like names, emails, job details) and in-transit (HTTPS). PostgREST leverages pgcrypto for encrypted fields (e.g., job_name, message).
Authentication: Hashed passwords (password_hash). Rate-limit brute-force attacks using login_attempts table and triggers (e.g., 5 attempts/5 min). PostgREST uses JWT tokens generated by Django for authentication.
Authorization: Role-based checks using PostgreSQL row-level security (RLS) policies (e.g., field users access own ticket_entries via user_id). Admins have exclusive access to event logs (GET /history) and admin-level alerts (GET /alerts?alert_type=in.(security,system)); managers can moderate user content; field users access personal data only. Audit logs for all edits/deletes (including admin and manager actions) in history table.
Compliance: User agreement to not share sensitive data. Support data export for privacy (e.g., GDPR-like) via GET /users or GET /ticket_entries.

3.2 Performance and Scalability

User Load: Handle 15+ concurrent users with low latency (<5s page loads). PostgRESTâ€™s direct database access optimizes query performance.
Scalability: Horizontal scaling via Docker containers (PostgREST, PostgreSQL, Redis, Django, Nginx). Use Gunicorn workers (2*cores +1) for Django, PostgREST for API. Optimize queries with indexes (e.g., idx_user_sessions_user_id, idx_alerts_unresolved). Cache frequent reads (e.g., user preferences) with Redis.
Availability: 99% uptime target. Asynchronous tasks via Celery/Redis to offload heavy operations.
Data Volume: Support growing tickets/jobs; partition tables if needed in future.

3.3 Usability and Accessibility

Responsiveness: Adapt to desktop/mobile using Bootstrap 5. Themes based on user preferences (user_preferred_light_or_dark_mode_mobile/desktop).
Accessibility: ARIA labels for widgets, keyboard navigation, high-contrast options.
Internationalization: Timezone support (default America/Los_Angeles, validated via pg_timezone_names).

3.4 Reliability

Error Handling: Graceful failures (e.g., failed login messages). Backups via pg_dump.
Monitoring: Log failed attempts, session activity, and all user actions (including admins/managers) for security tracking in login_attempts, history tables.

4. Technical Requirements
4.1 Architecture

RESTful Design: PostgREST auto-generates API endpoints for all tables/views (e.g., GET/POST/PATCH/DELETE /ticket_entries, /alerts, /users) and custom functions (e.g., POST /rpc/check_failed_logins). Django handles authentication, session management, and non-API logic.
Real-Time Features: WebSockets via Django Channels (Redis backend) for live updates (e.g., alerts, notifications), triggering PostgREST queries as needed.
Async Processing: Celery with Redis for background tasks (e.g., sending emails, escalating alerts).

4.2 Technology Stack

Backend: Python 3.12, Django, PostgREST (for RESTful API), Django Allauth (auth stubs), Django Ratelimit, Django Crispy Forms, Django Filter, Django Storages.
Database: PostgreSQL with pgcrypto extension. Adapter: psycopg2-binary.
Frontend: Django Bootstrap 5 (responsive UI), custom CSS for rounded widgets/themes.
Security/Encryption: Cryptography library, PostgREST JWT for API security.
Real-Time/Async: Channels, Channels Redis, Celery (with Redis).
Servers: Gunicorn (WSGI for Django), Uvicorn (ASGI for WebSockets), PostgREST (Haskell-based API server).
Other: Mail-parser (imports), Pillow (image handling), Requests (APIs), Python Decouple (env vars).

4.3 Development Environment

Tools: PyCharm Pro, Pipenv (virtual env), Docker (for containerization, including PostgREST).
Setup: Install dependencies via pipenv install (list from install.txt + extras like Celery, PostgREST). Configure PostgREST with PostgreSQL connection and JWT secret.
Testing: Unit/integration tests for auth, encryption, sessions, role-based access (including admin/manager permissions, PostgREST RLS policies). Coverage target: 80%.

4.4 Deployment and Maintenance
5.1 Environments

Local/Dev: PostgreSQL local, PostgREST server, Nginx for static files, Gunicorn/Uvicorn for Django.
Production: Docker Compose (PostgreSQL, PostgREST, Redis, Django, Nginx). HTTPS enforcement.

5.2 CI/CD

Version Control: Git with feature branches.
Pipeline: Automated tests/linting on push (e.g., GitHub Actions), including PostgREST endpoint tests.

5.3 Maintenance

Updates: Re-agree to terms on major changes, managed by admins via site-wide alerts (POST /alerts).
Monitoring: Track performance, errors, and admin-level alerts (security, system) via Django/PostgREST logs. Admins access event logs (GET /history) for auditing.
Risks: Data loss (mitigate with backups), bottlenecks (profile with tools like Django Debug Toolbar, optimize PostgREST queries).

Document Created Date: 2025-08-26
Document Modified Date: 2025-08-27
Version: 1.0.1
Update Notes:
- 2025-08-26 (v1.0.0): Initial creation.
- 2025-08-27 (v1.0.1): Aligned with build fixes for Docker/pyenv stability.
